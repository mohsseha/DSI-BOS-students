
from IPython.display import Image
Image(url='https://upload.wikimedia.org/wikipedia/commons/8/8a/STAN_ULAM_HOLDING_THE_FERMIAC.jpg')

Image('../assets/images/PyStan Diagram.PNG')

# This is a critical string that we need to pass from our main interface (Python) to the Stan interpretor 
'''
data {
// Defining your data 
}
transformed data{}

parameters {
// Defining the name of your parameter and it's numerical parameters
// Explicitly required 
}

transformed parameters{}

model {
// Specifying your model parameters
// Explicitly required
}

generated quantities{}
'''


# data {
# int<lower=0> n; 
# int<lower=0, upper=1> y[n]; 
# }
# parameters {
# real<lower=0, upper=1> theta; 
# }
# model {
# theta ~ beta(1, 1); 
# y ~ bernoulli(theta); 
# }
# '''

'Note - this is a lab answer'

'''
data {
    int<lower=0> n; 
    int<lower=0> heads; 
}
parameters {
    real<lower=0, upper=1> param;
}
model {
    param ~ beta(2, 2);
    heads ~ binomial(n, param);
}
'''

'Note - this is the lab answer '


data {
 int<lower = 0> n; // number of observations
 real y[n]; // response variable
 real x[n]; // predictor variable
}

parameters {
// Remember from high school y = ax + b
 real a; real b; 
 real<lower=0> sd; // standard deviation
}

transformed parameters {
 real target[n]; 
 
for(i in 1:n)
 target[i] <- a*x[i] + b;
}

model {
 y ~ normal(mu, sd);
}

'''

from __future__ import division
import pystan
import os
import pylab as py
import sys
import glob
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
%matplotlib inline
%precision 4
plt.style.use('ggplot')

# Load the data

housing = pd.read_csv('../assets/datasets/housing.csv')
housing.head(5)

# Build a dictionary for Stan model processing
dat = {'n': len(housing), 'x': housing.CRIM, 'y': housing.MEDV}


# Output the data to get a view of 

py.plot(housing.CRIM, housing.MEDV, 'yo')
py.show()

# Load the STAN model 

reg_model = '''data {
    int<lower=0> n;
    real x[n];
    real y[n];
}
parameters {
    real a;
    real b;
    real sigma;
}
transformed parameters {
    real mu[n];
    for (i in 1:n) {
        mu[i] <- a*x[i] + b;
        }
}
model {
    sigma ~ uniform(0, 20);  //Remember step 1?
    y ~ normal(mu, sigma); // Remember step 2?
}

'''

# # Note - This is a lab answer
# # Vectorize the reg model in STAN

# vectorize_reg =
# data {
#     int<lower=0> n;
#     int<lower=0> m;
#     matrix[n, m] x;
#     vector[n] y;
# }
# transformed data {
#     vector[n] cons;
#     matrix[n, m+1] x;

#     cons <- rep_vector(1, n);
#     x <- append_col(cons, xi);
# }
# parameters {
#     vector[k] beta;
#     real<lower=0> sigma;
# }
# model {
#     y ~ normal(xi * beta, sigma);
# }


import numpy
import pyximport
pyximport.install(setup_args={"script_args":["--compiler=mingw64"],
                              "include_dirs":numpy.get_include()},
                  reload_support=True)

model = pystan.stan(model_code = reg_model, n_jobs = 1, data = dat, chains=1) 

# Remember n_jobs = 1 is for Windows user 


Image('../assets/images/traceplot examples.PNG')

# Visualize the mean, and variance convergence using matplotlib

trace = model.extract()
plt.figure(figsize=(10,4))
plt.subplot(1,2,1);
plt.hist(trace['mu'][:], 25, histtype='step');
plt.subplot(1,2,2);

plt.hist(trace['sigma'][:], 25, histtype='step');

import seaborn as sns
sns.lmplot('CRIM', 'MEDV', housing)

from sklearn import linear_model

mod = linear_model.LinearRegression()
mod.fit(housing.AGE, housing.MEDV)

# Use the traceplot method from pystan to output the graph ... much easier than constructing from a histogram don't you think? 

model.traceplot()
py.show()

#Print your model here

print(model)


model.plot()
plt.show()


