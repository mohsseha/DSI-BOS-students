


l = [3,6,7,11,15,84]

def build_tree(l):
    tree = {}
    l.sort()
    if len(l) == 0:
        return
    if len(l)%2 == 0:
        tree["node"] = l[int(len(l)/2)]
        left_list = l[:int(len(l)/2)]
    if len(l)%2 != 0:
        tree["node"] = l[int(len(l)/2)-1]
        right_list = l[:int(len(l)/2)-1]
    tree['left'] = build_tree(left_list)
    tree['right'] = build_tree(right_list)
    return(tree)

build_tree(l)

def build_tree(l):
    

    return(tree)

l = [3,6,7,11,15,84]

build_tree(l)

import numpy as np

test_list = [-3,-2,-1,0,1,2,3]

def build_tree(number_list):
    sorted_list = np.sort(number_list)
   
    median_value_index = int(len(sorted_list) / 2)
    median = sorted_list[median_value_index]
   
    dictionary = {}
   
    left_dictionary = {'node': sorted_list[0]}
    for index in range(1, median_value_index + 1):
        if index < median_value_index:
            left_dictionary = {'node': sorted_list[index], 'left': left_dictionary}
   
    right_dictionary = {'node': sorted_list[len(sorted_list) - 1]}
    for index in reversed(range(median_value_index + 1, len(sorted_list - 1))):
        if index > median_value_index:
            right_dictionary = {'node': sorted_list[index - 1], 'right': right_dictionary}
   
    dictionary = {'left': left_dictionary, 'node': right_dictionary['node'], 'right': right_dictionary['right']}

   
    print("Median: ", median)
    print(sorted_list)
   
    return dictionary



test_tree = build_tree(test_list)

def finditem(tree,int):
    #given a binary tree and and integer, return a true if the integer is in the tree, else false
    found = False
    if tree["node"] == int:
        return True
    elif ("left" in tree.keys()) and tree["node"] > int:
        #print("going left")
        return finditem(tree["left"], int)
    elif ("right" in tree.keys()) and tree["node"] < int:
        #print("going right")
        return finditem(tree["right"], int)
    else:
        return found
    

for i in test_list:
    print(finditem(test_tree, i))
    

import sys
sys.getrecursionlimit()

def add_item(tree,int):
    #given a binary tree and and integer, return a true if the integer is in the tree, else false
    
    
    if (bool(tree) == False):
        tree['node'] = int
        return tree['node']
    elif (tree["node"] == int):
        return
    elif ("left" in tree.keys()) and tree["node"] > int:
        #print("going left")
        tree['left'] = add_item(tree["left"], int)
        return tree['left']
    elif ("right" in tree.keys()) and tree["node"] < int:
        #print("going right")
        tree['right'] = add_item(tree["right"], int)
        return tree['right']
    else:
        tree['node'] = int
        return tree['node']
    

l = [3,6,7,11,15,84]
some_tree ={}
for i in l:
    foo = add_item(some_tree, i)

foo


